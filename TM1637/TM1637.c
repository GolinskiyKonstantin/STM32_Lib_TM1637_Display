/*

  ******************************************************************************
  * @file 			( фаил ):   TM1637.c
  * @brief 		( описание ):  	Управление 7-сегментным 4 разрядным дисплеем через TM1637
  ******************************************************************************
  * @attention 	( внимание ):	//управление по двум портам ( настроины как выход без подтяжки )
								// Для работы всеголиш меняем на портах логические уровни
								// Используем библиотеку HAL, если не через HAL то перепределяем
				#define DIO(x)		HAL_GPIO_WritePin( GPIOA, GPIO_PIN_6, x ? GPIO_PIN_SET : GPIO_PIN_RESET)
				#define read_DIO	HAL_GPIO_ReadPin( GPIOA, GPIO_PIN_6 )
				#define CLK(x)		HAL_GPIO_WritePin( GPIOA, GPIO_PIN_7, x ? GPIO_PIN_SET : GPIO_PIN_RESET)
  ******************************************************************************
  
*/

/* Includes ----------------------------------------------------------*/
#include "TM1637.h"


//----------------------------------------------------------------------

//управление по двум портам ( настроины как выход без подтяжки )
// Для работы всеголиш меняем на портах логические уровни
// Используем библиотеку HAL, если не через HAL то перепределяем
#define DIO(x)		HAL_GPIO_WritePin( GPIOA, GPIO_PIN_6, x ? GPIO_PIN_SET : GPIO_PIN_RESET)
#define read_DIO	HAL_GPIO_ReadPin( GPIOA, GPIO_PIN_6 )
#define CLK(x)		HAL_GPIO_WritePin( GPIOA, GPIO_PIN_7, x ? GPIO_PIN_SET : GPIO_PIN_RESET)

uint8_t PointFlag = 0; 		// включение или отключение двоеточия 1-вул   0-выкл ( кроме режима часов там будут всегда )

//-----------------------------------------------------------------
// тип дисплея
#define D4036B 0
#define D4056A 1
// Устанавливаем наш тип дисплея
#define _DispType  D4036B
//-----------------------------------------------------------------

#define INDEX_NEGATIVE_SIGN	16
#define INDEX_BLANK			18 		// при выводе значения 2 или 3 разряда впереди будут добавляться нули если стоит 0 или пустое поле если стоит 18

#define DELAY_TIME 100				// кол-во микросекунл задержек в функциях

//-----------------------------------------------------------------1

uint8_t Cmd_DispCtrl;		// контрастность дисплея от 0 -7 
uint8_t DecPoint;
uint8_t BlankingFlag = 1;	// ставим 1 для работы с #define INDEX_BLANK

//-----------------------------------------------------------------

////////////////////////////////////
//
//      A
//     ---
//  F |   | B
//     -G-
//  E |   | C
//     ---
//      D
const uint8_t digitToSegment[] = {
 // XGFEDCBA
	
	// Для добавления ТОЧКп на дисплей нужно 8 байт поставить в 1
	// например чифра 1 будет 0x06,    // 1 0b00000110
	// с точкой на конце будет такой 0x86,    // 1 0b10000110
	
	// Когда отправляете (в TM1637) перекодированный по таблице сегментов байт, поднимите у него старший бит (data |= 0x80), 
	// будет вам десятичная точка у соответствующей цифры. Если поднимите старшие биты у всех (четырех) отправляемых байт, будет вам двоеточие.
	
			0x3f,    // 0 0b00111111
			0x06,    // 1 0b00000110
			0x5b,    // 2 0b01011011
			0x4f,    // 3 0b01001111
			0x66,    // 4 0b01100110
			0x6d,    // 5 0b01101101
			0x7d,    // 6 0b01111101
			0x07,    // 7 0b00000111
			0x7f,    // 8 0b01111111
			0x6f,    // 9 0b01101111
			0x77,    // A 0b01110111
			0x7c,    // b 0b01111100
			0x39,    // C 0b00111001
			0x5e,    // d 0b01011110
			0x79,    // E 0b01111001
			0x71,    // F 0b01110001
			0x40,    // - знак минус 0b01000000
			0x00     // отсудствие символа 0b00000000
  };

/////////////////////////////////////////////////////
	
/*
	******************************************************************************
	* @brief	 ( описание ):  Функция задержки в миклосекундах
	* @param	( параметры ):	Кол-во микросекунд
	* @return  ( возвращает ):	

	******************************************************************************
*/
void Delay_us (uint32_t i){
	for (; i> 0; i--);
}
//--------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  Функция для начала передачи команд или данных (активация )
	* @param	( параметры ):	
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1637_Generate_START (void){
	CLK(1);
	DIO(1);
	Delay_us (DELAY_TIME);
	DIO(0);
}
//--------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  Функция для конца передачи команд или данных ( окончание передачи )
	* @param	( параметры ):	
	* @return  ( возвращает ):	

	******************************************************************************
*/
void TM1637_Generate_STOP (void){
	CLK(0);
	Delay_us (DELAY_TIME);
	DIO(0);
	Delay_us (DELAY_TIME);
	CLK(1);
	Delay_us (DELAY_TIME);
	DIO(1);
}
//--------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  Функция передачи данных или коменд
	* @param	( параметры ):	1 байт данных или коменд
	* @return  ( возвращает ):	
					//ПЕРЕДАЧА ОТ МЛАДШЕГО К СТРАШЕМУ!!!НЕ СТАНДАРТ
	******************************************************************************
*/
void TM1637_WriteData (	uint8_t oneByte) {
	uint8_t i;
	for (i = 0; i <8; i++){
		CLK(0);
		
		if (oneByte & 0x01){ DIO(1); }
		else { DIO(0); }
		
		Delay_us (DELAY_TIME);
		oneByte = oneByte >> 1;
		CLK(1);
		Delay_us (DELAY_TIME);
	}
	
	CLK(0);
	Delay_us (DELAY_TIME);	
	DIO(0);
	while(read_DIO);
	DIO(1); 
	CLK(1);
	Delay_us (DELAY_TIME);		
	CLK(0);
}
//-----------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  меняем число  на его позицию  в массиве digitToSegment
	* @param	( параметры ):	1 байт цифра для отображения
	* @return  ( возвращает ):	1 байт из массива digitToSegment который формирует указаную цифру 
						( лед блоки на матрице )для отображения
		
	******************************************************************************
*/
int8_t TM1637_coding(uint8_t DispData){
	uint8_t PointData;
	if(PointFlag) PointData = 0x80;
	else PointData = 0;
	
	if(DispData == 0x7f) DispData = 0x00 + PointData; // 0x7f включена восмерка все индикаторы кроме точки
	else DispData = digitToSegment[DispData] + PointData;
	return DispData;
}
//--------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  меняем массив чискл от 1 до 4  на его позицию  в массиве digitToSegment
	* @param	( параметры ):	массив цифр для отображения
	* @return  ( возвращает ):	массив цифр из массива digitToSegment который формирует указануые цифры
						( лед блоки на матрице )для отображения
		
	******************************************************************************
*/
void TM1637_coding_all(uint8_t DispData[]){
	uint8_t PointData;
	uint8_t i;
	if(PointFlag) PointData = 0x80;
	else PointData = 0;
	
	for(i = 0;i < 4;i ++){
		if(DispData[i] == 0x7f)DispData[i] = 0x00 + PointData;
		else DispData[i] = digitToSegment[DispData[i]] + PointData; 
	}
	if((_DispType == D4056A)&&(DecPoint != 3)){
		DispData[DecPoint] += 0x80;
		DecPoint = 3;
	}
}
//-------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  разбиваем число на "сегменты" ввели 251 получили 2 5 1 для каждого сигмента
	* @param	( параметры ):	1 пар. само число, 2 пар. массив для хранения уже с разбитыми отдельными цыфрами
	* @return  ( возвращает ):			
	******************************************************************************
*/
void separate_Digit_to_digits(int16_t Digit,uint8_t SegArray[]){
	
	if((Digit > 9999)||(Digit < -999))return;
	if(Digit < 0){
		SegArray[0] = INDEX_NEGATIVE_SIGN;
		Digit = (Digit & 0x7fff);
		SegArray[1] = Digit/100;
		Digit %= 100;
		SegArray[2] = Digit / 10;
		SegArray[3] = Digit % 10;
		if(BlankingFlag){
			if(SegArray[1] == 0){
				SegArray[1] = INDEX_BLANK;
				if(SegArray[2] == 0) SegArray[2] = INDEX_BLANK;
			}
		}
	}
	else{
		SegArray[0] = Digit/1000;
		Digit %= 1000;
		SegArray[1] = Digit/100;
		Digit %= 100;
		SegArray[2] = Digit / 10;
		SegArray[3] = Digit % 10;
		if(BlankingFlag){
			if(SegArray[0] == 0){
				SegArray[0] = INDEX_BLANK;
				if(SegArray[1] == 0){
					SegArray[1] = INDEX_BLANK;
					if(SegArray[2] == 0) SegArray[2] = INDEX_BLANK;
				}
			}
		}
	}
	BlankingFlag = 1;
}
//------------------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  отображает один символ из массива
	* @param	( параметры ):	1 пар. номер позиции сегмент ( от 0 до 3 )
								2 пар. число которое хотим отобразить
	* @return  ( возвращает ):			
	******************************************************************************
*/
void TM1637_display(uint8_t Seg_N, int8_t DispData){
	int8_t SegData;
	SegData = TM1637_coding(DispData);
	TM1637_Generate_START();                                
	TM1637_WriteData(0x44);			// 1:фиксированный адресс
	TM1637_Generate_STOP();
	TM1637_Generate_START();
	TM1637_WriteData(Seg_N|0xc0);	// устанавливаем адресс старшие 2 бита должны быть 1(0xc0)+ номер сегмента
	TM1637_WriteData(SegData);		// отправляем "кодированные" данные для одного сегмента
	TM1637_Generate_STOP();
	TM1637_Generate_START();
	TM1637_WriteData(Cmd_DispCtrl);	// включаем дисплей с выставлленой яркостью;
	TM1637_Generate_STOP();
}
//----------------------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  отображение чисел от -999 до 9999
	* @param	( параметры ):	число от 1 до 4 разрядов от -999 до 9999
	* @return  ( возвращает ):			
	******************************************************************************
*/
void TM1637_display_all(uint16_t Digit) {
	uint8_t SegData[4];
	uint8_t i;
	separate_Digit_to_digits(Digit,SegData);
	TM1637_coding_all(SegData);
	
	TM1637_Generate_START();
	TM1637_WriteData(0x40);	// записать данные в дисплей
	TM1637_Generate_STOP();
	
	TM1637_Generate_START();
	TM1637_WriteData(0xc0);	// адрес первого сегмента 0xC0 
							// адрес второго сегмента 0xC1 
							// адрес третьего сегмента 0xC2
							// адрес четвертого сегмента 0xC3
							// адрес пятого сегмента 0xC4
							// адрес шестого сегмента 0xC5
	
	for(i=0;i < 4;i ++){	  
		TM1637_WriteData(SegData[i]);	// передаем значения для i-го сегмента
	}
	TM1637_Generate_STOP();
	  
	TM1637_Generate_START();
	TM1637_WriteData(Cmd_DispCtrl);	// включаем дисплей с текущей яркостью;
	TM1637_Generate_STOP();
}
//------------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  Включение и отключение экрана
	* @param	( параметры ):	1 ВКЛ     0 ВЫКЛ
	* @return  ( возвращает ):			
	******************************************************************************
*/
void TM1637_displayOnOff(uint8_t OnOff){
	TM1637_Generate_START();                                
	TM1637_WriteData(0x44);		// 1:фиксированный адресс
	TM1637_Generate_STOP();
	
	TM1637_Generate_START();  
	// для включения или выключения дисплея с сохранением текущей контрасности нужно ставить третий бит в 1 вкл 0 выкл	
	TM1637_WriteData(OnOff? (Cmd_DispCtrl | 1<<3) : (Cmd_DispCtrl & ~(1<<3)) );		// 0x80 выкл     0х88 вкл
	TM1637_Generate_STOP();
}
//-----------------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  Отчистка дисплея
	* @param	( параметры ):	
	* @return  ( возвращает ):			
	******************************************************************************
*/
void TM1637_clearDisplay(void) {
	uint8_t i;
	for(i=0;i<4;i++)TM1637_display(i,0x7f); 
}
//---------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  Яркость дисплея
	* @param	( параметры ):	режим яркости от 0 до 7 ( 0-мин    7-мах)
	* @return  ( возвращает ):			
	******************************************************************************
*/
void TM1637_brightness(uint8_t brightness){
  Cmd_DispCtrl = 0x88 + brightness;
}
//---------------------------------------------------------------------------------

/*
	******************************************************************************
	* @brief	 ( описание ):  Отображение в виде часов 4 разряда
	* @param	( параметры ):	1 пар. часы   2 пар. минуты
	* @return  ( возвращает ):			
	******************************************************************************
*/
void TM1637_displayTime(uint8_t hours,uint8_t minutes){
	uint16_t time = (hours*100)+minutes;
	PointFlag =  PointFlag ? 0:1;  
	TM1637_display_all(time);
}	
//----------------------------------------------------------------------------------

/************************ (C) COPYRIGHT GKP *****END OF FILE****/
